{"language":"Solidity","sources":{"src/utils/ext/zksync/ERC1967Factory.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {ERC1967Proxy} from \"./ERC1967Proxy.sol\";\nimport {UpgradeableBeacon} from \"./UpgradeableBeacon.sol\";\nimport {ERC1967BeaconProxy} from \"./ERC1967BeaconProxy.sol\";\n\n/// @notice A factory for deploying minimal ERC1967 proxies on ZKsync.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/ext/zksync/ERC1967Factory.sol)\n///\n/// @dev This factory can be used in one of the following ways:\n/// 1. Deploying a fresh copy with each contract.\n///    Easier to test. In ZKsync VM, factory dependency bytecode is not included in the\n///    factory bytecode, so you do not need to worry too much about bytecode size limits.\n/// 2. Loading it from a storage variable which is set to the canonical address.\n///    See: ERC1967FactoryConstants.ADDRESS.\n///\n/// This factory is crafted to be compatible with both ZKsync VM and regular EVM.\n/// This is so that when ZKsync achieves full EVM equivalence,\n/// this factory can still be used via the fresh copy per contract way.\ncontract ERC1967Factory {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The caller is not authorized to call the function.\n    error Unauthorized();\n\n    /// @dev The proxy deployment failed.\n    error DeploymentFailed();\n\n    /// @dev The upgrade failed.\n    error UpgradeFailed();\n\n    /// @dev The salt does not start with the caller.\n    error SaltDoesNotStartWithCaller();\n\n    /// @dev No initialization code hash exists for the instance hash.\n    error NoInitCodeHashFound();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                           EVENTS                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The admin of a `instance` has been changed. Applies to both proxies and beacons.\n    event AdminChanged(address indexed instance, address indexed admin);\n\n    /// @dev The implementation for `instance` has been upgraded. Applies to both proxies and beacons.\n    event Upgraded(address indexed instance, address indexed implementation);\n\n    /// @dev A proxy has been deployed.\n    event ProxyDeployed(\n        address indexed proxy, address indexed implementation, address indexed admin\n    );\n\n    /// @dev A beacon has been deployed.\n    event BeaconDeployed(\n        address indexed beacon, address indexed implementation, address indexed admin\n    );\n\n    /// @dev A beacon proxy has been deployed.\n    event BeaconProxyDeployed(address indexed beaconProxy, address indexed beacon);\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          STORAGE                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The hash of the proxy.\n    bytes32 public proxyHash;\n\n    /// @dev The hash of the upgradeable beacon.\n    bytes32 public beaconHash;\n\n    /// @dev The hash of the beacon proxy.\n    bytes32 public beaconProxyHash;\n\n    /// @dev Whether to use the CREATE2 address prediction workflow for ZKsync VM.\n    bool internal _useZKsyncCreate2Prediction;\n\n    /// @dev Maps the instance hash to the initialization code hash.\n    mapping(bytes32 => bytes32) internal _initCodeHashes;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                        CONSTRUCTOR                         */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    constructor() payable {\n        bytes32 proxySalt = keccak256(abi.encode(address(this), bytes32(\"proxySalt\")));\n        address proxyAddress = address(new ERC1967Proxy{salt: proxySalt}());\n\n        proxyHash = _extcodehash(proxyAddress);\n        beaconHash = _extcodehash(address(new UpgradeableBeacon()));\n        beaconProxyHash = _extcodehash(address(new ERC1967BeaconProxy()));\n\n        if (_predictDeterministicAddressZKsync(proxyHash, proxySalt) == proxyAddress) {\n            _useZKsyncCreate2Prediction = true;\n        } else {\n            _initCodeHashes[proxyHash] = keccak256(type(ERC1967Proxy).creationCode);\n            _initCodeHashes[beaconHash] = keccak256(type(UpgradeableBeacon).creationCode);\n            _initCodeHashes[beaconProxyHash] = keccak256(type(ERC1967BeaconProxy).creationCode);\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      ADMIN FUNCTIONS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the admin of the `instance`.\n    /// Returns `address(0)` if `instance` is a beacon proxy.\n    /// Works for both proxies and beacons.\n    function adminOf(address instance) public view returns (address admin) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            admin := mul(sload(instance), gt(instance, 0xff))\n        }\n    }\n\n    /// @dev Sets the admin of the `instance`.\n    /// The caller of this function must be the admin of `instance`.\n    /// Works for both proxies and beacons.\n    function changeAdmin(address instance, address admin) public {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(eq(sload(instance), caller())) {\n                mstore(0x00, 0x82b42900) // `Unauthorized()`.\n                revert(0x1c, 0x04)\n            }\n            sstore(instance, admin)\n        }\n        emit AdminChanged(instance, admin);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     UPGRADE FUNCTIONS                      */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Upgrades `instance` to point to `implementation`.\n    /// The caller of this function must be the admin of `instance`.\n    /// Works for both proxies and beacons.\n    function upgrade(address instance, address implementation) public payable {\n        upgradeAndCall(instance, implementation, _emptyData());\n    }\n\n    /// @dev Upgrades `instance` to point to `implementation`.\n    /// Then, calls it with abi encoded `data`.\n    /// The caller of this function must be the admin of `instance`.\n    /// Works for both proxies and beacons.\n    function upgradeAndCall(address instance, address implementation, bytes calldata data)\n        public\n        payable\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(eq(sload(instance), caller())) {\n                mstore(0x00, 0x82b42900) // `Unauthorized()`.\n                revert(0x1c, 0x04)\n            }\n            let m := mload(0x40)\n            mstore(m, implementation)\n            calldatacopy(add(m, 0x20), data.offset, data.length)\n            if iszero(call(gas(), instance, callvalue(), m, add(0x20, data.length), 0x00, 0x00)) {\n                if iszero(returndatasize()) {\n                    mstore(0x00, 0x55299b49) // `UpgradeFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                returndatacopy(0x00, 0x00, returndatasize())\n                revert(0x00, returndatasize())\n            }\n        }\n        emit Upgraded(instance, implementation);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      PROXY DEPLOYMENT                      */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Deploys a proxy for `implementation`, with `admin`, and returns its address.\n    /// The value passed into this function will be forwarded to the proxu.\n    function deployProxy(address implementation, address admin) public payable returns (address) {\n        return deployProxyAndCall(implementation, admin, _emptyData());\n    }\n\n    /// @dev Deploys a proxy for `implementation`, with `admin`, and returns its address.\n    /// The value passed into this function will be forwarded to the proxu.\n    /// Then, calls the proxy with abi encoded `data`.\n    function deployProxyAndCall(address implementation, address admin, bytes calldata data)\n        public\n        payable\n        returns (address)\n    {\n        return _deploy(0, uint160(implementation), uint160(admin), \"\", false, data);\n    }\n\n    /// @dev Deploys a proxy for `implementation`, with `admin`, `salt`,\n    /// and returns its deterministic address.\n    /// The value passed into this function will be forwarded to the proxy.\n    function deployProxyDeterministic(address implementation, address admin, bytes32 salt)\n        public\n        payable\n        returns (address)\n    {\n        return deployProxyDeterministicAndCall(implementation, admin, salt, _emptyData());\n    }\n\n    /// @dev Deploys a proxy for `implementation`, with `admin`, `salt`,\n    /// and returns its deterministic address.\n    /// The value passed into this function will be forwarded to the proxy.\n    /// Then, calls the proxy with abi encoded `data`.\n    function deployProxyDeterministicAndCall(\n        address implementation,\n        address admin,\n        bytes32 salt,\n        bytes calldata data\n    ) public payable returns (address) {\n        return _deploy(0, uint160(implementation), uint160(admin), salt, true, data);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     BEACON DEPLOYMENT                      */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Deploys a beacon with `implementation` and `admin`, and returns its address.\n    function deployBeacon(address implementation, address admin) public returns (address) {\n        return _deploy(1, uint160(implementation), uint160(admin), \"\", false, _emptyData());\n    }\n\n    /// @dev Deploys a beacon with `implementation` and `admin`, with `salt`,\n    /// and returns its deterministic address.\n    function deployBeaconDeterministic(address implementation, address admin, bytes32 salt)\n        public\n        payable\n        returns (address)\n    {\n        return _deploy(1, uint160(implementation), uint160(admin), salt, true, _emptyData());\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  BEACON PROXY DEPLOYMENT                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Deploys a beacon proxy referring to `beacon`, and returns its address.\n    /// The value passed into this function will be forwarded to the beacon proxy.\n    function deployBeaconProxy(address beacon) public payable returns (address) {\n        return deployBeaconProxyAndCall(beacon, _emptyData());\n    }\n\n    /// @dev Deploys a beacon proxy referring to `beacon`, and returns its address.\n    /// The value passed into this function will be forwarded to the beacon proxy.\n    /// Then, calls the beacon proxy with abi encoded `data`.\n    function deployBeaconProxyAndCall(address beacon, bytes calldata data)\n        public\n        payable\n        returns (address)\n    {\n        return _deploy(2, uint160(beacon), 0, \"\", false, data);\n    }\n\n    /// @dev Deploys a beacon proxy referring to `beacon`, with `salt`,\n    /// and returns its deterministic address.\n    /// The value passed into this function will be forwarded to the beacon proxy.\n    function deployBeaconProxyDeterministic(address beacon, bytes32 salt)\n        public\n        payable\n        returns (address)\n    {\n        return deployBeaconProxyDeterministicAndCall(beacon, salt, _emptyData());\n    }\n\n    /// @dev Deploys a beacon proxy referring to `beacon`, with `salt`,\n    /// and returns its deterministic address.\n    /// The value passed into this function will be forwarded to the beacon proxy.\n    /// Then, calls the beacon proxy with abi encoded `data`.\n    function deployBeaconProxyDeterministicAndCall(\n        address beacon,\n        bytes32 salt,\n        bytes calldata data\n    ) public payable returns (address) {\n        return _deploy(2, uint160(beacon), 0, salt, true, data);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       PUBLIC HELPERS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the address of the instance deployed with `salt`.\n    /// `instanceHash` is one of `proxyHash`, `beaconProxyHash`, `beaconHash`.\n    function predictDeterministicAddress(bytes32 instanceHash, bytes32 salt)\n        public\n        view\n        returns (address)\n    {\n        if (_useZKsyncCreate2Prediction) {\n            return _predictDeterministicAddressZKsync(instanceHash, salt);\n        }\n        return _predictDeterministicAddressRegularEVM(instanceHash, salt);\n    }\n\n    /// @dev Returns the implementation of `instance`.\n    /// If `instance` is not deployed, returns `address(0)`.\n    function implementationOf(address instance) public view returns (address result) {\n        bytes32 h = _extcodehash(instance);\n        if (h == proxyHash || h == beaconProxyHash) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let s := staticcall(gas(), instance, 0x00, 0x01, 0x00, 0x20)\n                if iszero(and(gt(returndatasize(), 0x1f), s)) { revert(0x00, 0x00) }\n                result := mload(0x00)\n            }\n        } else if (h == beaconHash) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                mstore(0x00, 0x5c60da1b) // `implementation()`.\n                let s := staticcall(gas(), instance, 0x1c, 0x04, 0x00, 0x20)\n                if iszero(and(gt(returndatasize(), 0x1f), s)) { revert(0x00, 0x00) }\n                result := mload(0x00)\n            }\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      INTERNAL HELPERS                      */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Validates the salt and returns it.\n    function _validateSalt(bytes32 salt) internal view returns (bytes32) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If the salt does not start with the zero address or the caller.\n            if iszero(or(iszero(shr(96, salt)), eq(caller(), shr(96, salt)))) {\n                mstore(0x00, 0x2f634836) // `SaltDoesNotStartWithCaller()`.\n                revert(0x1c, 0x04)\n            }\n        }\n        return salt;\n    }\n\n    /// @dev Performs the deployment optionality to deploy deterministically with a `salt`.\n    function _deploy(\n        uint256 codeType,\n        uint256 target,\n        uint256 admin,\n        bytes32 salt,\n        bool useSalt,\n        bytes calldata data\n    ) internal returns (address instance) {\n        if (codeType == 0) {\n            instance = address(\n                useSalt ? new ERC1967Proxy{salt: _validateSalt(salt)}() : new ERC1967Proxy()\n            );\n            /// @solidity memory-safe-assembly\n            assembly {\n                sstore(instance, admin)\n            }\n            emit ProxyDeployed(instance, address(uint160(target)), address(uint160(admin)));\n        } else if (codeType == 1) {\n            instance = address(\n                useSalt\n                    ? new UpgradeableBeacon{salt: _validateSalt(salt)}()\n                    : new UpgradeableBeacon()\n            );\n            /// @solidity memory-safe-assembly\n            assembly {\n                sstore(instance, admin)\n            }\n            emit BeaconDeployed(instance, address(uint160(target)), address(uint160(admin)));\n        } else {\n            instance = address(\n                useSalt\n                    ? new ERC1967BeaconProxy{salt: _validateSalt(salt)}()\n                    : new ERC1967BeaconProxy()\n            );\n            emit BeaconProxyDeployed(instance, address(uint160(target)));\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Revert if the creation fails.\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            // Make the initialization call.\n            let m := mload(0x40)\n            mstore(m, target)\n            calldatacopy(add(m, 0x20), data.offset, data.length)\n            if iszero(call(gas(), instance, callvalue(), m, add(0x20, data.length), 0x00, 0x00)) {\n                // Revert with the `DeploymentFailed` selector if there is no error returndata.\n                if iszero(returndatasize()) {\n                    mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                // Otherwise, bubble up the returned error.\n                returndatacopy(0x00, 0x00, returndatasize())\n                revert(0x00, returndatasize())\n            }\n        }\n    }\n\n    /// @dev Returns the `extcodehash` of `instance`.\n    function _extcodehash(address instance) internal view returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := extcodehash(instance)\n        }\n    }\n\n    /// @dev Helper function to return an empty bytes calldata.\n    function _emptyData() internal pure returns (bytes calldata data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            data.length := 0\n        }\n    }\n\n    /// @dev Returns the predicted `CREATE2` address on ZKsync VM.\n    function _predictDeterministicAddressZKsync(bytes32 instanceHash, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        bytes32 prefix = keccak256(\"zksyncCreate2\");\n        bytes32 emptyStringHash = keccak256(\"\");\n        /// @solidity memory-safe-assembly\n        assembly {\n            // The following is `keccak256(abi.encode(...))`.\n            let m := mload(0x40)\n            mstore(m, prefix)\n            mstore(add(m, 0x20), address())\n            mstore(add(m, 0x40), salt)\n            mstore(add(m, 0x60), instanceHash)\n            mstore(add(m, 0x80), emptyStringHash)\n            predicted := keccak256(m, 0xa0)\n        }\n    }\n\n    /// @dev Returns the predicted `CREATE2` address on regular EVM.\n    function _predictDeterministicAddressRegularEVM(bytes32 instanceHash, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        bytes32 initCodeHash = _initCodeHashes[instanceHash];\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(initCodeHash) {\n                mstore(0x00, 0xa3a58d1c) // `NoInitCodeHashFound()`.\n                revert(0x1c, 0x04)\n            }\n            // The following is `keccak256(abi.encodePacked(...))`.\n            mstore8(0x00, 0xff) // Write the prefix.\n            mstore(0x35, initCodeHash)\n            mstore(0x01, shl(96, address()))\n            mstore(0x15, salt)\n            predicted := keccak256(0x00, 0x55)\n            mstore(0x35, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n}\n"},"src/utils/ext/zksync/ERC1967Proxy.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice A sufficiently minimal ERC1967 proxy tailor-made for ZKsync.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/ext/zksync/ERC1967Proxy.sol)\ncontract ERC1967Proxy {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                           EVENTS                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Emitted when the proxy's implementation is upgraded.\n    event Upgraded(address indexed implementation);\n\n    /// @dev `keccak256(bytes(\"Upgraded(address)\"))`.\n    uint256 private constant _UPGRADED_EVENT_SIGNATURE =\n        0xbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          STORAGE                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The ERC-1967 storage slot for the implementation in the proxy.\n    /// `uint256(keccak256(\"eip1967.proxy.implementation\")) - 1`.\n    bytes32 internal constant _ERC1967_IMPLEMENTATION_SLOT =\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /// @dev The storage slot for the deployer.\n    /// `uint256(keccak256(\"ERC1967Proxy.deployer\")) - 1`.\n    bytes32 internal constant _ERC1967_PROXY_DEPLOYER_SLOT =\n        0xc20b8dda59e1f49cae9bbc6c3744edc7900ba02880cd7b33b5b82a96197202ba;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                        CONSTRUCTOR                         */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    constructor() payable {\n        /// @solidity memory-safe-assembly\n        assembly {\n            sstore(_ERC1967_PROXY_DEPLOYER_SLOT, caller())\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          FALLBACK                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    fallback() external payable virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x40, 0) // Optimization trick to remove free memory pointer initialization.\n            // For the special case of 1-byte calldata, return the implementation.\n            if eq(calldatasize(), 1) {\n                mstore(0x00, sload(_ERC1967_IMPLEMENTATION_SLOT))\n                return(0x00, 0x20)\n            }\n            // Deployer workflow.\n            if eq(caller(), sload(_ERC1967_PROXY_DEPLOYER_SLOT)) {\n                let newImplementation := calldataload(0x00)\n                sstore(_ERC1967_IMPLEMENTATION_SLOT, newImplementation)\n                if gt(calldatasize(), 0x20) {\n                    let n := sub(calldatasize(), 0x20)\n                    calldatacopy(0x00, 0x20, n)\n                    if iszero(delegatecall(gas(), newImplementation, 0x00, n, 0x00, 0x00)) {\n                        // Bubble up the revert if the call reverts.\n                        returndatacopy(0x00, 0x00, returndatasize())\n                        revert(0x00, returndatasize())\n                    }\n                }\n                // Emit the {Upgraded} event.\n                log2(0x00, 0x00, _UPGRADED_EVENT_SIGNATURE, newImplementation)\n                stop() // End the context.\n            }\n            // Perform the delegatecall.\n            let implementation := sload(_ERC1967_IMPLEMENTATION_SLOT)\n            calldatacopy(0x00, 0x00, calldatasize())\n            let s := delegatecall(gas(), implementation, 0x00, calldatasize(), 0x00, 0x00)\n            returndatacopy(0x00, 0x00, returndatasize())\n            if iszero(s) { revert(0x00, returndatasize()) }\n            return(0x00, returndatasize())\n        }\n    }\n}\n"},"src/utils/ext/zksync/UpgradeableBeacon.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice A sufficiently minimal upgradeable beacon tailor-made for ZKsync.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/ext/zksync/UpgradeableBeacon.sol)\ncontract UpgradeableBeacon {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                           EVENTS                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Emitted when the proxy's implementation is upgraded.\n    event Upgraded(address indexed implementation);\n\n    /// @dev `keccak256(bytes(\"Upgraded(address)\"))`.\n    uint256 private constant _UPGRADED_EVENT_SIGNATURE =\n        0xbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          STORAGE                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev To store the implementation.\n    uint256 private __implementation;\n\n    /// @dev For upgrades / initialization.\n    uint256 private __deployer;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                        CONSTRUCTOR                         */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    constructor() payable {\n        __deployer = uint256(uint160(msg.sender));\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*               UPGRADEABLE BEACON OPERATIONS                */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the implementation stored in the beacon.\n    /// See: https://eips.ethereum.org/EIPS/eip-1967#beacon-contract-address\n    function implementation() public view returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := sload(__implementation.slot)\n        }\n    }\n\n    fallback() external virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x40, 0) // Optimization trick to remove free memory pointer initialization.\n            let newImplementation := calldataload(0x00)\n            // Revert if the caller is not the deployer. We will still allow the implementation\n            // to be set to an empty contract for simplicity.\n            if iszero(eq(caller(), sload(__deployer.slot))) { revert(0x00, 0x00) }\n            sstore(__implementation.slot, newImplementation)\n            // Emit the {Upgraded} event.\n            log2(0x00, 0x00, _UPGRADED_EVENT_SIGNATURE, newImplementation)\n        }\n    }\n}\n"},"src/utils/ext/zksync/ERC1967BeaconProxy.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice A sufficiently minimal ERC1967 beacon proxy tailor-made for ZKsync.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/ext/zksync/ERC1967BeaconProxy.sol)\ncontract ERC1967BeaconProxy {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                           EVENTS                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Emitted when the proxy's beacon is upgraded.\n    event BeaconUpgraded(address indexed beacon);\n\n    /// @dev `keccak256(bytes(\"BeaconUpgraded(address)\"))`.\n    uint256 private constant _BEACON_UPGRADED_EVENT_SIGNATURE =\n        0x1cf3b03a6cf19fa2baba4df148e9dcabedea7f8a5c07840e207e5c089be95d3e;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          STORAGE                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The ERC-1967 storage slot for the implementation in the proxy.\n    /// `uint256(keccak256(\"eip1967.proxy.implementation\")) - 1`.\n    bytes32 internal constant _ERC1967_BEACON_SLOT =\n        0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /// @dev The storage slot for the deployer.\n    /// `uint256(keccak256(\"ERC1967BeaconProxy.deployer\")) - 1`.\n    bytes32 internal constant _ERC1967_BEACON_PROXY_DEPLOYER_SLOT =\n        0xabc1f855dddf3277214739f5a08d8b9db61505a97fd0c09e835a2d800705b3bc;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                        CONSTRUCTOR                         */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    constructor() payable {\n        /// @solidity memory-safe-assembly\n        assembly {\n            sstore(_ERC1967_BEACON_PROXY_DEPLOYER_SLOT, caller())\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          FALLBACK                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    fallback() external payable virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x40, 0) // Optimization trick to remove free memory pointer initialization.\n            // For the special case of 1-byte calldata, return the implementation.\n            if eq(calldatasize(), 1) {\n                mstore(0x00, 0x5c60da1b) // `implementation()`.\n                let s := staticcall(gas(), sload(_ERC1967_BEACON_SLOT), 0x1c, 0x04, 0x00, 0x20)\n                if iszero(and(gt(returndatasize(), 0x1f), s)) { revert(0x00, 0x00) }\n                return(0x00, 0x20) // Return the implementation.\n            }\n            // Deployer workflow.\n            if eq(caller(), sload(_ERC1967_BEACON_PROXY_DEPLOYER_SLOT)) {\n                sstore(_ERC1967_BEACON_SLOT, calldataload(0x00))\n                // Emit the {Upgraded} event.\n                log2(0x00, 0x00, _BEACON_UPGRADED_EVENT_SIGNATURE, calldataload(0x00))\n                stop() // End the context.\n            }\n            // Query the beacon.\n            mstore(0x00, 0x5c60da1b) // `implementation()`.\n            let s := staticcall(gas(), sload(_ERC1967_BEACON_SLOT), 0x1c, 0x04, 0x00, 0x20)\n            if iszero(and(gt(returndatasize(), 0x1f), s)) { revert(0x00, 0x00) }\n            let implementation := mload(0x00)\n            // Perform the delegatecall.\n            calldatacopy(0x00, 0x00, calldatasize())\n            s := delegatecall(gas(), implementation, 0x00, calldatasize(), 0x00, 0x00)\n            returndatacopy(0x00, 0x00, returndatasize())\n            if iszero(s) { revert(0x00, returndatasize()) }\n            return(0x00, returndatasize())\n        }\n    }\n}\n"}},"settings":{"viaIR":false,"codegen":"yul","remappings":["forge-std/=lib/forge-std/src/","forge-zksync-std/=lib/forge-zksync-std/src/"],"evmVersion":"cancun","outputSelection":{"*":{"":[],"*":["abi"]}},"optimizer":{"enabled":true,"mode":"3","fallback_to_optimizing_for_size":false,"disable_system_request_memoization":true},"metadata":{},"libraries":{},"enableEraVMExtensions":false,"forceEVMLA":false}}
